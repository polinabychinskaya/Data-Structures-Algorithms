Imagine you visiting a website: you click the links on the nav bar,
when you want to go back, you click the arrow in the left upper corner

But how does the website know where to place you?
#Example: https://www.cnn.com/ <---> https://www.cnn.com/world/ <---> https://www.cnn.com/europe/

Option 1: Use an array to store those values [https://www.cnn.com/,  https://www.cnn.com/world/,  https://www.cnn.com/europe/]
Issues: You can not use a static array, because the data set grows. 
Similarly, you cannot use dynamic array as it needs memory relocation and copying

Option 2: Use a linked list https://www.cnn.com/ ---> https://www.cnn.com/world/ ---> https://www.cnn.com/europe/
Issues: You have to iterate through all the linked list, time complexity O(n)

Option 3: Stack - LIFO (last in, first out)
|https://www.cnn.com/europe/| <--- push 3 pop out 1 --->
|https://www.cnn.com/world/ | <--- push 2 pop out 2 --->
|https://www.cnn.com/       | <--- push 1 pop out 3 --->
 ---------------------------

Push/Pop Out --> BigO(1)
Search element by value --> BigO(n)

Cases to use:
1. Function calling
2. Ctrl Z

Function stack (Стек вызова):
Когда компьютер выполняет программу и доходит до вызова какой-то функции, 
ему нужно ненадолго переключиться, чтобы эту самую функцию выполнить. 
Чтобы запомнить, где он остановился, компьютер сохраняет в памяти специальные закладки — 
так называемые точки перехода. Область памяти, где хранятся точки перехода, как раз и называется стеком вызовов.

В точке перехода хранится всё, чтобы компьютер быстро и безболезненно вернулся к выполнению основного кода: 
значения переменных, аргументы функций и адрес возврата — то место, куда компьютер должен перейти после 
окончания подпрограммы. Жизненная аналогия для точки перехода — это чекпойнт в игре: добежали, сохранились 
и можете пойти спокойно пить чай, пребывая в уверенности, что сможете начать с того же места.

Если внутри одной функции произойдёт вызов другой функции, история аналогичная: компьютер поставит 
на паузу выполнение первой, сохранит в стеке точку перехода, а затем перейдёт к выполнению второй. 
Этот принцип будет работать для любой степени вложенности функции, вплоть до рекурсии.

Чтобы было понятнее, изобразим весь этот процесс на схеме. Представим, 
что у нас есть программа с тремя функциями: первая вызывает вторую, вторая — третью и так далее.

Шаг 1. Компьютер выполняет основную программу и доходит до вызова функции 1. 
Он прерывает выполнение основной программы, помещает адрес возврата в стек и переходит к выполнению функции 1.

Шаг 2. Компьютер выполняет функцию 1 и доходит до вызова функции 2. Он прерывает выполнение функции 1, 
помещает её адрес возврата в стек и выполняет функцию 2.

Шаг 3. Компьютер заканчивает выполнение функции 2, считывает и удаляет с вершины стека адрес возврата функции 1. 
Затем он переходит к функции 1 и продолжает её выполнение с инструкции, находящейся по адресу возврата.

Шаг 4. Компьютер заканчивает выполнение функции 1, считывает и удаляет с вершины стека адрес 
возврата основной программы. Затем он переходит к основной программе и продолжает её выполнение с 
указанного адреса. Стек полностью очищается до следующего вызова.